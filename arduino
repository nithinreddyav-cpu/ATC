/* esp32_controller.ino
   ESP32 UDP-based controller for water-surface robotic collector
   - Motor control (L298/TB6612 style)
   - 3x long-range ultrasonic for obstacle avoidance (200 cm threshold)
   - 1x short-range ultrasonic (10 cm) triggers servo (90->180->90)
   - Listens for UDP JSON commands from laptop
*/

#include <WiFi.h>
#include <WiFiUdp.h>
#include <ArduinoJson.h>
#include <Servo.h>

// ---------- WiFi ----------
const char* SSID = "YOUR_WIFI_SSID";
const char* PASS = "YOUR_WIFI_PASSWORD";
const int UDP_PORT = 8888;
WiFiUDP udp;
IPAddress laptopIP; // optional caching

// ---------- Pins (match wiring above) ----------
const int MOTOR_A_IN1 = 16;
const int MOTOR_A_IN2 = 17;
const int MOTOR_B_IN1 = 18;
const int MOTOR_B_IN2 = 19;
const int MOTOR_ENA_CHANNEL = 0;   // LEDC channel
const int MOTOR_ENB_CHANNEL = 1;

const int MOTOR_PWM_PIN_A = 21;
const int MOTOR_PWM_PIN_B = 22;

const int TRIG_FRONT = 32;
const int ECHO_FRONT = 33;
const int TRIG_LEFT  = 25;
const int ECHO_LEFT  = 26;
const int TRIG_RIGHT = 27;
const int ECHO_RIGHT = 14;
const int TRIG_SHORT = 12;
const int ECHO_SHORT = 13;

const int SERVO_PIN = 23;
Servo pickupServo;

// thresholds (cm)
const float LONG_THRESHOLD = 200.0;
const float SHORT_TRIGGER = 10.0;

// motor speeds
const int PWM_FREQ = 20000;
const int PWM_RES = 8; // 8-bit
const int DEFAULT_SPEED = 190; // 0-255 (approx)
const int TURN_SPEED = 160;

// runtime state
unsigned long lastObstacleAvoidMillis = 0;
const unsigned long OBSTACLE_CHECK_INTERVAL = 120; // ms

// ---------- Utility: ultrasonic distance ----------
long readUltrasonicCM(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 30000); // timeout 30ms
  if (duration == 0) return 9999; // no echo (very far)
  long cm = duration / 29 / 2;
  return cm;
}

// ---------- Motor control ----------
void setupMotorPins() {
  pinMode(MOTOR_A_IN1, OUTPUT);
  pinMode(MOTOR_A_IN2, OUTPUT);
  pinMode(MOTOR_B_IN1, OUTPUT);
  pinMode(MOTOR_B_IN2, OUTPUT);

  // configure PWM channels
  ledcSetup(MOTOR_ENA_CHANNEL, PWM_FREQ, 8);
  ledcAttachPin(MOTOR_PWM_PIN_A, MOTOR_ENA_CHANNEL);

  ledcSetup(MOTOR_ENB_CHANNEL, PWM_FREQ, 8);
  ledcAttachPin(MOTOR_PWM_PIN_B, MOTOR_ENB_CHANNEL);
}

void motorStop() {
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN1, LOW);
  digitalWrite(MOTOR_B_IN2, LOW);
  ledcWrite(MOTOR_ENA_CHANNEL, 0);
  ledcWrite(MOTOR_ENB_CHANNEL, 0);
}

void motorForward(int speed = DEFAULT_SPEED) {
  digitalWrite(MOTOR_A_IN1, HIGH);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN1, HIGH);
  digitalWrite(MOTOR_B_IN2, LOW);
  ledcWrite(MOTOR_ENA_CHANNEL, speed);
  ledcWrite(MOTOR_ENB_CHANNEL, speed);
}

void motorBackward(int speed = DEFAULT_SPEED) {
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, HIGH);
  digitalWrite(MOTOR_B_IN1, LOW);
  digitalWrite(MOTOR_B_IN2, HIGH);
  ledcWrite(MOTOR_ENA_CHANNEL, speed);
  ledcWrite(MOTOR_ENB_CHANNEL, speed);
}

void motorTurnLeft(int speed = TURN_SPEED) {
  digitalWrite(MOTOR_A_IN1, LOW);
  digitalWrite(MOTOR_A_IN2, HIGH);
  digitalWrite(MOTOR_B_IN1, HIGH);
  digitalWrite(MOTOR_B_IN2, LOW);
  ledcWrite(MOTOR_ENA_CHANNEL, speed);
  ledcWrite(MOTOR_ENB_CHANNEL, speed);
}

void motorTurnRight(int speed = TURN_SPEED) {
  digitalWrite(MOTOR_A_IN1, HIGH);
  digitalWrite(MOTOR_A_IN2, LOW);
  digitalWrite(MOTOR_B_IN1, LOW);
  digitalWrite(MOTOR_B_IN2, HIGH);
  ledcWrite(MOTOR_ENA_CHANNEL, speed);
  ledcWrite(MOTOR_ENB_CHANNEL, speed);
}

// ---------- Obstacle avoidance ----------
bool checkAndAvoidObstacles() {
  // read sensors
  long dFront = readUltrasonicCM(TRIG_FRONT, ECHO_FRONT);
  long dLeft  = readUltrasonicCM(TRIG_LEFT, ECHO_LEFT);
  long dRight = readUltrasonicCM(TRIG_RIGHT, ECHO_RIGHT);
  // If any less than LONG_THRESHOLD, take action
  if (dFront < LONG_THRESHOLD || dLeft < LONG_THRESHOLD || dRight < LONG_THRESHOLD) {
    // Simple strategy:
    // If front obstacle detected: back up and turn away from the closest side
    if (dFront < LONG_THRESHOLD) {
      motorBackward(DEFAULT_SPEED);
      delay(400);
      if (dLeft > dRight) {
        motorTurnLeft();
      } else {
        motorTurnRight();
      }
      delay(400);
      motorStop();
      return true;
    } else if (dLeft < LONG_THRESHOLD) {
      // turn right a bit
      motorTurnRight();
      delay(300);
      motorStop();
      return true;
    } else if (dRight < LONG_THRESHOLD) {
      motorTurnLeft();
      delay(300);
      motorStop();
      return true;
    }
  }
  return false;
}

// ---------- Pickup servo routine ----------
void pickupSequence() {
  // short-range sensor must confirm target at under 10cm first
  long d = readUltrasonicCM(TRIG_SHORT, ECHO_SHORT);
  if (d <= SHORT_TRIGGER) {
    Serial.println("SHORT RANGE object confirmed, actuating servo");
    // rotate from 90 to 180, wait, then back to 90
    pickupServo.write(180);
    delay(900);
    // (optional: actuate gripper here)
    pickupServo.write(90);
    delay(400);
  } else {
    Serial.println("SHORT RANGE not close enough (d=" + String(d) + "cm)");
  }
}

// ---------- UDP command processing ----------
void processUdpCommand(char* buf, int len, IPAddress remoteIP, uint16_t remotePort) {
  // sample input: {"cmd":"navigate","pos":"left","label":"plastic"}
  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, buf, len);
  if (err) {
    Serial.println("JSON parse failed");
    return;
  }
  const char* cmd = doc["cmd"] | "";
  if (strcmp(cmd, "navigate") == 0) {
    const char* pos = doc["pos"] | "center";
    Serial.println("Navigate command: " + String(pos));
    // Simple navigation: lateral adjustments then forward
    if (strcmp(pos, "left") == 0) {
      // turn left a bit, then forward
      motorTurnLeft();
      delay(350);
      motorForward();
      delay(700);
      motorStop();
    } else if (strcmp(pos, "right") == 0) {
      motorTurnRight();
      delay(350);
      motorForward();
      delay(700);
      motorStop();
    } else {
      // center -> go forward brief
      motorForward();
      delay(900);
      motorStop();
    }
  } else if (strcmp(cmd, "stop_and_pick") == 0) {
    Serial.println("Stop and pick");
    motorStop();
    delay(200);
    // confirm short-range then actuate servo
    pickupSequence();
  } else if (strcmp(cmd, "stop") == 0) {
    motorStop();
  } else {
    Serial.println("Unknown cmd:");
    Serial.println(cmd);
  }

  // Optionally send ack back
  StaticJsonDocument<128> ack;
  ack["ack"] = "ok";
  ack["cmd"] = cmd;
  char out[128];
  size_t n = serializeJson(ack, out);
  udp.beginPacket(remoteIP, remotePort);
  udp.write((uint8_t*)out, n);
  udp.endPacket();
}

// ---------- Setup & loop ----------
void setup() {
  Serial.begin(115200);
  delay(500);

  // pins
  setupMotorPins();
  pinMode(TRIG_FRONT, OUTPUT); pinMode(ECHO_FRONT, INPUT);
  pinMode(TRIG_LEFT, OUTPUT);  pinMode(ECHO_LEFT, INPUT);
  pinMode(TRIG_RIGHT, OUTPUT); pinMode(ECHO_RIGHT, INPUT);
  pinMode(TRIG_SHORT, OUTPUT); pinMode(ECHO_SHORT, INPUT);

  pickupServo.attach(SERVO_PIN);
  pickupServo.write(90); // initial position

  // WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASS);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected. IP: ");
  Serial.println(WiFi.localIP());

  udp.begin(UDP_PORT);
  Serial.print("UDP listening on port ");
  Serial.println(UDP_PORT);
}

void loop() {
  // 1) check for incoming UDP
  int packetSize = udp.parsePacket();
  if (packetSize) {
    char incoming[512];
    int len = udp.read(incoming, 512);
    incoming[len] = 0;
    IPAddress remoteIP = udp.remoteIP();
    uint16_t remotePort = udp.remotePort();
    Serial.print("Received packet from ");
    Serial.println(remoteIP);
    processUdpCommand(incoming, len, remoteIP, remotePort);
  }

  // 2) Periodic obstacle checking
  unsigned long now = millis();
  if (now - lastObstacleAvoidMillis > OBSTACLE_CHECK_INTERVAL) {
    bool avoided = checkAndAvoidObstacles();
    lastObstacleAvoidMillis = now;
    (void)avoided;
  }

  // 3) Autonomous short-range detection: if an object is detected within short threshold while searching,
  // optionally do an auto pick (this is optional - we assume selection comes from laptop)
  // long dshort = readUltrasonicCM(TRIG_SHORT, ECHO_SHORT);
  // if (dshort <= SHORT_TRIGGER) {
  //   Serial.println("Auto short-range trigger");
  //   motorStop();
  //   pickupSequence();
  // }

  delay(20);
}
