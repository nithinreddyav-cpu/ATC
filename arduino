#include <WiFi.h>
#include <WiFiUdp.h>
#include <ArduinoJson.h>
#include <Servo.h>

const char* SSID = "YOUR_SSID";
const char* PASS = "YOUR_PASSWORD";

WiFiUDP udp;
const int UDP_PORT = 8888;

unsigned long nowMs = 0;

// ---------------- MOTOR PINS ---------------------
#define IN1 16
#define IN2 17
#define IN3 18
#define IN4 19
#define PWM_A 21
#define PWM_B 22

int SPEED_FORWARD = 180;
int SPEED_TURN = 150;

// ---------------- ULTRASONICS --------------------
#define TF_TRIG 32
#define TF_ECHO 33

#define TL_TRIG 25
#define TL_ECHO 26

#define TR_TRIG 27
#define TR_ECHO 14

#define TS_TRIG 12
#define TS_ECHO 13

float long_limit = 200;
float short_limit = 10;

// ---------------- SERVO --------------------------
Servo servo;
int servoPos = 90;
bool servoActive = false;
unsigned long servoStart = 0;

// ---------------- TIMERS -------------------------
unsigned long lastObstacleCheck = 0;
unsigned long lastMotorAction = 0;
unsigned long motorActionTime = 0;

// --------------- STATES --------------------------
String motorState = "stop";
String navDirection = "center";

long readCM(int trig, int echo) {
  digitalWrite(trig, LOW); delayMicroseconds(2);
  digitalWrite(trig, HIGH); delayMicroseconds(10);
  digitalWrite(trig, LOW);

  long dur = pulseIn(echo, HIGH, 25000);
  if (dur <= 0) return 999;
  return dur / 29 / 2;
}

void motorStop() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);
  ledcWrite(0, 0);
  ledcWrite(1, 0);
}

void motorForward() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  ledcWrite(0, SPEED_FORWARD);
  ledcWrite(1, SPEED_FORWARD);
}

void turnLeft() {
  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  ledcWrite(0, SPEED_TURN);
  ledcWrite(1, SPEED_TURN);
}

void turnRight() {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);
  ledcWrite(0, SPEED_TURN);
  ledcWrite(1, SPEED_TURN);
}

void smoothServoUpdate() {
  if (!servoActive) return;

  if (millis() - servoStart < 600) {
    servo.write(180);
  } else if (millis() - servoStart < 1100) {
    // hold
  } else if (millis() - servoStart < 1700) {
    servo.write(90);
  } else {
    servoActive = false;
    servo.write(90);
  }
}

void attemptPickup() {
  long d = readCM(TS_TRIG, TS_ECHO);
  if (d < short_limit) {
    servoActive = true;
    servoStart = millis();
  }
}

void obstacleAvoidance() {
  long dF = readCM(TF_TRIG, TF_ECHO);
  long dL = readCM(TL_TRIG, TL_ECHO);
  long dR = readCM(TR_TRIG, TR_ECHO);

  if (dF < long_limit) {
    motorStop();
    motorActionTime = 400;
    motorState = "back";
    lastMotorAction = millis();
    return;
  }
  if (dL < long_limit) {
    motorStop();
    motorActionTime = 300;
    motorState = "right";
    lastMotorAction = millis();
    return;
  }
  if (dR < long_limit) {
    motorStop();
    motorActionTime = 300;
    motorState = "left";
    lastMotorAction = millis();
    return;
  }
}

void updateMotor() {
  if (millis() - lastMotorAction < motorActionTime) {
    if (motorState == "forward") motorForward();
    else if (motorState == "left") turnLeft();
    else if (motorState == "right") turnRight();
    else if (motorState == "back") ; // already stopped
    return;
  }

  if (motorState != "stop") {
    motorStop();
    motorState = "stop";
  }
}

void processCommand(String jsonStr) {
  StaticJsonDocument<200> doc;
  deserializeJson(doc, jsonStr);

  String cmd = doc["cmd"];

  if (cmd == "navigate") {
    navDirection = doc["pos"].as<String>();
    if (navDirection == "left") motorState = "left";
    else if (navDirection == "right") motorState = "right";
    else motorState = "forward";

    motorActionTime = 500;
    lastMotorAction = millis();
  }

  else if (cmd == "stop_and_pick") {
    motorState = "stop";
    motorStop();
    attemptPickup();
  }

  else if (cmd == "scan") {
    motorState = "forward";
    motorActionTime = 400;
    lastMotorAction = millis();
  }
}

void setup() {
  Serial.begin(115200);

  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);

  ledcSetup(0, 20000, 8);
  ledcAttachPin(PWM_A, 0);
  ledcSetup(1, 20000, 8);
  ledcAttachPin(PWM_B, 1);

  pinMode(TF_TRIG, OUTPUT); pinMode(TF_ECHO, INPUT);
  pinMode(TL_TRIG, OUTPUT); pinMode(TL_ECHO, INPUT);
  pinMode(TR_TRIG, OUTPUT); pinMode(TR_ECHO, INPUT);
  pinMode(TS_TRIG, OUTPUT); pinMode(TS_ECHO, INPUT);

  servo.attach(23);
  servo.write(90);

  WiFi.begin(SSID, PASS);
  while (WiFi.status() != WL_CONNECTED) delay(200);

  udp.begin(UDP_PORT);
}

void loop() {
  nowMs = millis();

  int pkt = udp.parsePacket();
  if (pkt) {
    char data[256];
    int len = udp.read(data, 256);
    data[len] = 0;
    processCommand(String(data));
  }

  if (nowMs - lastObstacleCheck > 70) {
    obstacleAvoidance();
    lastObstacleCheck = nowMs;
  }

  smoothServoUpdate();

  updateMotor();
}
